<!DOCTYPE html>

<html lang="en">

	<head>
		<title>Rawkets | A multiplayer game built using HTML5 canvas and WebSockets</title>

		<meta charset="utf-8">
		<meta name="description" content="Rawkets is a massively multiplayer game in which you can shoot and interact with other players, in real-time, in space! It uses the latest Web technologies, including HTML5 canvas and WebSockets.">

		<link rel="stylesheet" href="style/reset.css">
		<link rel="stylesheet" href="style/rawkets_fonts.css">
		<link rel="stylesheet" href="style/rawkets.css">
	</head>

	<body>
		<canvas id="canvas" width="400" height="400"></canvas>
		<div id="overlay">
			<header id="header">
				<h1>Rawkets</h1>
				<nav>
					<ul id="tabs">
						<li><a id="tabGame" class="active" href="#"><span class="label">Game</span></a></li>
						<li><a id="tabSettings" href="#"><span class="label">Settings</span></a></li>
						<li><a id="tabAbout" href="#"><span class="label">About</span></a></li>
					</ul>
				</nav>
			</header>

			<section id="chat">
				<ol id="chatDisplay"></ol>
				<!-- Should probably be a form input -->
				<div id="chatInput"><p></p><span id="chatLimit"></span></div>
			</section>

			<section id="intro">
				<p>A multiplayer space shooter built using HTML5 canvas and WebSockets</p>
				<p>
					<form id="play" action="">
						<input type="text" id="username" tabindex="1" placeholder="Username">
						<input type="submit" id="join" value="Join the battle">
						<p id="usernameError"></p>
					</form>
				</p>
			</section>

			<section id="settings">
				<h1>Settings</h1>
				<p>You'll soon be able to control a variety of features in the game.</p>
			</section>

			<section id="about">
				<h1>About Rawkets</h1>
				<p>Part experiment, part game; Rawkets is a multiplayer space shooter built using some of the latest Web technologies. It's fun, addictive, and a challenge to master. The game is in active development, so expect regular updates with awesome new features. This is just the beginning!</p>

				<h2>Built using open Web technologies</h2>
				<p>Rawkets has been specifically created with open Web technologies, like WebSockets, Node, and HTML5 canvas. The purpose of creating the game has been to learn about these technologies, and to see just how possible it is to create fun multiplayer experience within the browser.</p>

				<h2>Created by Rob Hawkes</h2>
				<p>Rob thrives on solving problems through code. He's addicted to visual programming, and can't get enough of HTML5 canvas. Most of his waking life is spent working on crazy projects involving all sorts of new and exciting technologies, both on-line and off. Aside from his practical work, Rob has written a book called "<a href="http://rawkes.com/foundationcanvas">Foundation HTML5 Canvas</a>", which is all about making games with canvas. He is a <a href="http://rawkes.com/blog/2011/03/25/becoming-a-mozilla-technical-evangelist">Technical Evangelist</a> for Mozilla.</p>

				<p>Visit <a href="http://rawkes.com">Rob's website</a>, or <a href="http://twitter.com/robhawkes">follow him</a> on Twitter.</a>
			</section>

			<footer id="statistics">
				<p id="killedBy"></p>
				<p id="score">0</p>
				<p id="playerCount">0 fighters online</p>
				<p id="updates"><a href="http://twitter.com/rawkets">Send me development updates</a></p>
			</footer>
		</div>

		<div id="soundContainer"></div>

		<script type="text/javascript" src="js/jquery.min.js"></script>
		<script type="text/javascript" src="js/jquery.xcolor.min.js"></script>
		<script type="text/javascript" src="js/swfobject/swfobject.js"></script>
		<script type="text/javascript" src="js/socket.io.min.js"></script>
		<script type="text/javascript" src="js/bison.js"></script>

		<script type="text/javascript">
			// Only using jQuery for website UI, not core game logic
			$("#tabs a").css({textIndent: 0}).each(function() {
				var span = $(this).find("span");
				var spanWidth = span.outerWidth();
				var tabWidth = $(this).outerWidth();
				var tabEdge = $(this).offset().left+tabWidth;
				var overEdge = (tabEdge+(spanWidth/2) < window.innerWidth) ? false : true;
				var offset = (!overEdge) ? Math.floor((tabWidth/2)-(spanWidth/2)) : 10;
				span.css({right: offset});

				var anchor = $("<span class='anchor'></span>");
				var anchorClass = (overEdge) ? "right" : "";
				anchor.addClass(anchorClass);
				span.append(anchor);
			}).mouseover(function() {
				var span = $(this).find("span");
				//var offset = span.
				span.toggle();
			}).mouseout(function() {
				var span = $(this).find("span");
				span.toggle();
			});

			$("#play").submit(function(e) {
				e.preventDefault();
				var username = $("#username").val();
				//console.log(username, username.match(/^[\d\w]*$/));
				if (username != "" && username.match(/^[\d\w]*$/)) {
					if (username.length > 15) {
						$("#usernameError").html("Please keep your username 15 characters or less");
						return;
					}
					checkUsername(username);
				} else {
					$("#usernameError").html("Please only use letters and numbers in your username");
				};
			});

			$("#tabGame").click(function(e) {
				e.preventDefault();
				$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0)"});
				$("#settings, #about").hide();
				if(!localPlayer) {
					$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0.5)"});
					$("#intro").fadeIn();
				};
				$("#tabSettings, #tabAbout").removeClass("active");
				$(this).addClass("active");
			});

			$("#tabSettings").click(function(e) {
				e.preventDefault();
				$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0.5)"});
				$("#intro, #about").hide();
				$("#tabSettings, #tabGame").removeClass("active");
				$(this).addClass("active");
				$("#settings").fadeIn();
			});

			$("#tabAbout").click(function(e) {
				e.preventDefault();
				$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0.5)"});
				$("#intro, #settings").hide();
				$("#tabGame, #tabSettings").removeClass("active");
				$(this).addClass("active");
				$("#about").fadeIn();
			});

			// DOM elements
			var canvas = document.getElementById("canvas");
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight-111;
			var ctx = canvas.getContext("2d");
			var usernameError = document.getElementById("usernameError");
			var score = document.getElementById("score");
			var playerCount = document.getElementById("playerCount");
			var killedBy = document.getElementById("killedBy");

			// Clone function
			function clone(obj) {
			    if (null == obj || "object" != typeof obj) return obj;

			    // Handle Array
			    if (obj instanceof Array) {
			        var copy = [], i, len = obj.length;
			        for (i = 0; i < len; ++i) {
			            copy[i] = clone(obj[i]);
			        }
			        return copy;
			    };

			    // Handle Object
			    if (obj instanceof Object) {
			        var copy = {};
			        for (var attr in obj) {
			            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);
			        }
			        return copy;
			    };

			    throw new Error("Unable to copy obj! Its type isn't supported.");
			};

			// Netgraph
			var NetGraph = function() {
				var width = 300,
					height = 50,
					maxPing = 200,
					maxData = 60000,
					pings = [],
					tmpData = [],
					data = [],
					packetsPerSecond = 0,
					bytesPerSecond = 0; // This is actuallt characters per second, not bytes

				var addPing = function(ping) {
					if (pings.length == 150) {
						pings.shift(); // Remove first ping
					};

					pings.push(ping);
				};

				var addTmpData = function(value) {
					tmpData.push(value);
				};

				var addData = function() {
					if (data.length == 150) {
						data.shift(); // Remove first data
					};

					var d, tmpDataCount = tmpData.length, value = 0;
					for (d = 0; d < tmpDataCount; d++) {
						value += tmpData[d];
					};

					packetsPerSecond = tmpData.length;
					bytesPerSecond = value;
					tmpData = [];

					data.push(value);
				};

				var draw = function(ctx) {
					ctx.save();
					ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
					ctx.fillRect(0, 0, width, height);

					ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
					ctx.font = "Bold 8px Verdana";
					ctx.fillText("0ms", width+4, height-2);
					ctx.fillText(maxPing+"ms", width+4, 10);

					var ms = (pings.length > 0) ? pings[pings.length-1] : 0;
					ctx.fillStyle = "rgb(255, 255, 255)";
					ctx.fillText(ms+"ms", 4, 10);

					ctx.fillText(packetsPerSecond+" p/s", 4, 25);
					ctx.fillText(bytesPerSecond+" b/s", 4, 40);

					var d, dx, dy, dat, dataCount = data.length;
					if (dataCount > 0) {
						ctx.strokeStyle = "rgb(0, 255, 0)";
						ctx.lineWidth = 1;
						ctx.beginPath();
						ctx.moveTo(width-(dataCount*2), height-(data[0]/(maxData/height)));
						for (d = 0; d < dataCount; d++) {
							dat = data[d];
							dx = (width-(dataCount*2))+(d*2);
							dy = height-(dat/(maxData/height));

							ctx.lineTo(dx, dy);
						};
						ctx.stroke();
					};

					var p, px, py, ping, pingCount = pings.length;
					if (pingCount > 0) {
						ctx.strokeStyle = "rgb(255, 255, 255)";
						ctx.lineWidth = 1;
						ctx.beginPath();
						ctx.moveTo(width-(pingCount*2), height-(pings[0]/(maxPing/height)));
						for (p = 0; p < pingCount; p++) {
							ping = pings[p];
							px = (width-(pingCount*2))+(p*2);
							py = height-(ping/(maxPing/height));

							ctx.lineTo(px, py);
						};
						ctx.stroke();
					};

					ctx.restore();
				};

				return {
					addPing: addPing,
					addTmpData: addTmpData,
					addData: addData,
					draw: draw
				}
			};

			// Vector object
			var Vector = function(opts) {
				// Public variables
				var x = opts.x || 0,
					y = opts.y || 0;

				return {
					x: x,
					y: y
				};
			};

			// Player state object
			var PlayerState = function(opts) {
				// Public variables
				var currentKeys = {left: false, right: false, up: false, down: false, space: false, mine: false},
					previousKeys = clone(currentKeys),
					activeKeys = clone(currentKeys),
					pos = new Vector({x: opts.x, y: opts.y}),
					angle = opts.angle,
					moving = false,
					health = 100;

				var updateKeys = function() {
					previousKeys.left = currentKeys.left;
					previousKeys.right = currentKeys.right;
					previousKeys.up = currentKeys.up;
					previousKeys.down = currentKeys.down;
					previousKeys.space = currentKeys.space;
					previousKeys.mine = currentKeys.mine;

					currentKeys.left = activeKeys.left;
					currentKeys.right = activeKeys.right;
					currentKeys.up = activeKeys.up;
					currentKeys.down = activeKeys.down;
					currentKeys.space = activeKeys.space;
					currentKeys.mine = activeKeys.mine;
				};

				return {
					pos: pos,
					angle: angle,
					moving: moving,
					currentKeys: currentKeys,
					previousKeys: previousKeys,
					activeKeys: activeKeys,
					updateKeys: updateKeys,
					health: health
				};
			};

			// Player object
			var Player = function(opts) {
				// Public variables
				var id = opts.id,
					username = opts.username,
					idleAge = 0,
					local = opts.local,
					currentState = new PlayerState({x: opts.x, y: opts.y, angle: opts.angle}),
					previousState = clone(currentState),
					colour = {c: opts.colour};

				var draw = function(ctx) {
					var pos = (local) ? new Vector({x: canvas.width/2, y: canvas.height/2}) : viewport.worldToScreen(currentState.pos.x, currentState.pos.y);
					if (pos) {
						ctx.save();
						ctx.translate(pos.x, pos.y);

						// Health ring
						ctx.save();

						ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
						ctx.lineWidth = 10;
						ctx.beginPath();
						ctx.arc(0, 0, 40, 0, Math.PI*2, false);
						ctx.closePath();
						ctx.stroke();

						ctx.rotate(-Math.PI/2);
						ctx.strokeStyle = "hsla("+120*(currentState.health/100)+", 100%, 50%, 0.1)";
						ctx.beginPath();
						ctx.arc(0, 0, 40, 0, -(Math.PI*2)*(currentState.health/100), true);
						ctx.stroke();

						ctx.restore();

						if (username) {
							ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
							ctx.font = "Bold 10px Verdana";
							ctx.fillText(username, 15, 3);
						};

						// Rotate canvas for rocket and flame
						ctx.rotate(currentState.angle);

						// Draw weapon reticle
						ctx.save();
						ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
						ctx.lineWidth = 4;
						ctx.beginPath();
						ctx.moveTo(35, 0);
						ctx.lineTo(45, 0);
						ctx.closePath();
						ctx.stroke();
						ctx.restore();

						// Draw flame
						var flameHeight;
						if (currentState.moving) {
							flameHeight = Math.floor(8+(Math.random()*4));
							ctx.fillStyle = "orange";
							ctx.beginPath();
							ctx.moveTo(-(6+flameHeight), 0);
							ctx.lineTo(-6, -2);
							ctx.lineTo(-6, 2);
							ctx.closePath();
							ctx.fill();
						};

						// Draw rocket
						ctx.fillStyle = (currentState.health > 0) ? "rgb(255, 255, 255)" : "rgb(150, 150, 150)";
						ctx.beginPath();
						ctx.moveTo(-7, -6);
						ctx.lineTo(7, 0);
						ctx.lineTo(-7, 6);
						ctx.closePath();
						ctx.fill();

						if (colour.c && currentState.health > 0) {
							// Draw decal
							ctx.fillStyle = "rgb("+colour.c+")";
							ctx.beginPath();
							ctx.arc(-3, 0, 2, 0, Math.PI*2, false);
							ctx.closePath();
							ctx.fill();
						};

						ctx.restore();
					};
				};

				return {
					id: id,
					username: username,
					idleAge: idleAge,
					draw: draw,
					currentState: currentState,
					previousState: previousState,
					colour: colour
				};
			};

			// Bullet state object
			var BulletState = function(opts) {
				// Public variables
				var pos = new Vector({x: opts.x, y: opts.y}),
					angle = opts.angle,
					vel = 8000,
					acc = new Vector({x: Math.cos(opts.angle)*vel, y:Math.sin(opts.angle)*vel}),
					age = 0;

				return {
					pos: pos,
					age: age,
					acc: acc,
					angle: angle
				};
			};

			// Bullet object
			var Bullet = function(opts) {
				// Public variables
				var id = opts.id,
					currentState = new BulletState({x: opts.x, y: opts.y, angle: opts.angle}),
					previousState = clone(currentState);

				var update = function() {
					// Update previous state
					previousState.pos = clone(currentState.pos);
					previousState.age = currentState.age;

					currentState.age++;

					// This is always going to be a little off because latency isn't being compensated
					// Also, dropped packets will mean a bullet could seemingly never appear on the client
					currentState.pos.x = 2 * currentState.pos.x - previousState.pos.x + currentState.acc.x * dtdt;
					currentState.pos.y = 2 * currentState.pos.y - previousState.pos.y + currentState.acc.y * dtdt;
				};

				// Public methods
				var draw = function(ctx) {
					var localPos = viewport.worldToScreen(currentState.pos.x, currentState.pos.y);
					ctx.save();
					ctx.translate(localPos.x, localPos.y);
					ctx.rotate(currentState.angle);
					ctx.fillStyle = "rgb(255, 255, 0)";
					ctx.fillRect(-6, -1, 6, 2);
					ctx.restore();
				};

				return {
					id: id,
					currentState: currentState,
					update: update,
					draw: draw
				};
			};

			// Mine state object
			var MineState = function(opts) {
				// Public variables
				var pos = new Vector({x: opts.x, y: opts.y}),
					age = 0;

				return {
					pos: pos,
					age: age
				};
			};

			// Mine object
			var Mine = function(opts) {
				// Public variables
				var id = opts.id,
					playerId = opts.playerId,
					currentState = new MineState({x: opts.x, y: opts.y});

				var update = function() {
					currentState.age++;
				};

				// Public methods
				var draw = function(ctx) {
					var localPos = viewport.worldToScreen(currentState.pos.x, currentState.pos.y);
					ctx.save();
					ctx.translate(localPos.x, localPos.y);

					var colour = (playerId == localPlayer.id) ? "0, 255, 0" : "255, 0, 0";

					// Damage radius
					ctx.fillStyle = "rgba("+colour+", 0.2)";
					ctx.beginPath();
					ctx.arc(0, 0, 30, 0, Math.PI*2, false);
					ctx.closePath();
					ctx.fill();

					// Mine
					ctx.fillStyle = "rgb("+colour+")";
					ctx.beginPath();
					ctx.arc(0, 0, 5, 0, Math.PI*2, false);
					ctx.closePath();
					ctx.fill();

					ctx.restore();
				};

				return {
					id: id,
					currentState: currentState,
					update: update,
					draw: draw
				};
			};

			// Viewport object
			var Viewport = function(width, height) {
				var worldWidth = 2000,
					worldHeight = 2000,
					dimensions = {width: width, height: height},
					pos = new Vector({x: worldWidth/2, y: worldHeight/2}), // Centre of the world
					previousPos = clone(pos),
					flareLeftLower = [new Image(), false],
					flareLeftUpper = [new Image(), false],
					flareRightLower = [new Image(), false],
					flareRightUpper = [new Image(), false];

				flareLeftLower[0].src = "style/img/game_flare_left_lower.png";
				flareLeftLower[0].onload = function() {
					flareLeftLower[1] = true;
				};

				flareLeftUpper[0].src = "style/img/game_flare_left_upper.png";
				flareLeftUpper[0].onload = function() {
					flareLeftUpper[1] = true;
				};

				flareRightLower[0].src = "style/img/game_flare_right_lower.png";
				flareRightLower[0].onload = function() {
					flareRightLower[1] = true;
				};

				flareRightUpper[0].src = "style/img/game_flare_right_upper.png";
				flareRightUpper[0].onload = function() {
					flareRightUpper[1] = true;
				};

				var withinBounds = function(x, y) {
					if (x > (pos.x - dimensions.width/2)-20 &&
						x < (pos.x + dimensions.width/2)+20 &&
						y > (pos.y - dimensions.height/2)-20 &&
						y < (pos.y + dimensions.height/2)+20) {
						return true;
					};

					return false;
				};

				var worldToScreen = function(x, y) {
					var screenPos = new Vector({x: 0, y: 0});

					screenPos.x = (pos.x - dimensions.width/2) - x;
					screenPos.y = (pos.y - dimensions.height/2) - y;

					screenPos.x *= -1;
					screenPos.y *= -1;

					return screenPos;
				};

				var worldXToScreenX = function(x) {
					var x = (pos.x - dimensions.width/2) - x;
					x *= -1;

					return x;
				};

				var worldYToScreenY = function(y) {
					var y = (pos.y - dimensions.height/2) - y;
					y *= -1;

					return y;
				};

				var draw = function(ctx) {
					ctx.strokeStyle = "rgba(200, 200, 200, 0.2)";
					ctx.lineWidth = 20;

					var drawPos = new Vector({x: 0, y: 0});
					var drawWidth = 0;
					var drawHeight = 0;

					if (0 > (pos.x - width/2)) {
						drawPos.x = worldXToScreenX(0);
					} else {
						drawPos.x = 0;
					};

					if (0 > (pos.y - height/2)) {
						drawPos.y = worldYToScreenY(0);
					} else {
						drawPos.y = 0;
					};

					if (worldWidth < (pos.x + dimensions.width/2)) {
						drawWidth = worldXToScreenX(worldWidth)-drawPos.x;
					} else {
						drawWidth = dimensions.width;
					};

					if (worldHeight < (pos.y + dimensions.height/2)) {
						drawHeight = worldYToScreenY(worldHeight)-drawPos.y;
					} else {
						drawHeight = dimensions.height;
					};

					ctx.strokeRect(drawPos.x-ctx.lineWidth, drawPos.y-ctx.lineWidth, drawWidth+(ctx.lineWidth*2), drawHeight+(ctx.lineWidth*2));

					// Draw lens flares
					var flarePos = new Vector({x: 0, y: 0});
					if (flareLeftLower[1]) {
						flarePos.x = 0-((pos.x/worldWidth)*294);
						flarePos.y = dimensions.height-123-((pos.y/worldHeight)*150);
						ctx.drawImage(flareLeftLower[0], flarePos.x, flarePos.y);
					};

					if (flareLeftUpper[1]) {
						flarePos.x = 0-((pos.x/worldWidth)*379);
						flarePos.y = 30+((pos.y/worldHeight)*250);
						ctx.drawImage(flareLeftUpper[0], flarePos.x, flarePos.y);
					};

					if (flareRightLower[1]) {
						flarePos.x = dimensions.width-((pos.x/worldWidth)*380);
						flarePos.y = dimensions.height-193-((pos.y/worldHeight)*150);
						ctx.drawImage(flareRightLower[0], flarePos.x, flarePos.y);
					};

					if (flareRightUpper[1]) {
						flarePos.x = dimensions.width-((pos.x/worldWidth)*317);
						flarePos.y = 10+((pos.y/worldHeight)*150);
						ctx.drawImage(flareRightUpper[0], flarePos.x, flarePos.y);
					};
				};

				return {
					pos: pos,
					dimensions: dimensions,
					previousPos: previousPos,
					withinBounds: withinBounds,
					worldToScreen: worldToScreen,
					draw: draw
				};
			};

			// Star class
			var Star = function(x, y) {
				var pos = new Vector({x: x, y: y}),
					z = Math.random()*0.3;

				var update = function(movementDelta) {
					pos.x -= movementDelta.x*(z+0.3);
					pos.y -= movementDelta.y*(z+0.3);
				};

				var draw = function(ctx) {
					ctx.fillStyle = "rgba(255, 255, 255, "+(0.4+(z*0.3))+")";
					ctx.beginPath();
					ctx.arc(pos.x, pos.y, (z*10), 0, Math.PI*2, false);
					ctx.closePath();
					ctx.fill();
				};

				return {
					pos: pos,
					update: update,
					draw: draw
				};
			};

			function createStars() {
				stars = [];
				starsOriginalWidth = canvas.width;
				starsOriginalHeight = canvas.height;
				var s;
				for (s = 0; s < 20; s++) {
					stars.push(new Star(Math.random()*canvas.width, Math.random()*canvas.height));
				};
			};

			// Sound class
			var Sound = function() {
				var container = document.getElementById("soundContainer"),
					muted = false;

				var play = function(soundName) {
					if (!this.muted) {
						switch (soundName) {
							case "background":
								container.playBackground();
								break;
							case "thrust":
								container.playThrust();
								break;
							case "laser":
								container.playLaser();
								break;
							case "respawn":
								container.playRespawn();
								break;
							case "die":
								container.playDie();
								break;
						};
					};
				};

				var stop = function(soundName) {
					if (!this.muted) {
						switch (soundName) {
							case "background":
								container.stopBackground();
								break;
							case "thrust":
								container.stopThrust();
								break;
						};
					};
				};

				var mute = function() {
					stop("background");
					stop("thrust");
					this.muted = true;
				};

				var unmute = function() {
					this.muted = false;
					play("background");
				};

				return {
					play: play,
					stop: stop,
					muted: muted,
					mute: mute,
					unmute: unmute
				};
			};

			// Message formatter helper
			function formatMessage(type, args) {
				var msg = {z: type};

				for (var arg in args) {
					// Don't overwrite the message type
					if (arg != "z")
						msg[arg] = args[arg];
				};

				//return JSON.stringify(msg);
				return BISON.encode(msg);
			};

			// Add remote player
			function addRemotePlayer(opts) {
				if (playerById(opts.id)) {
					return;
				};

				var id = opts.id,
					username = opts.username,
					state = opts.state,
					colour = opts.colour,
					localPos,
					player;

				player = new Player({id: id, local: false, x: 0, y: 0, angle: 0, colour: colour, username: username});

				player.currentState.pos = state.pos;
				player.currentState.angle = state.angle;

				remotePlayers.push(player);
				console.log("Add player: ", id);
			};

			// Update player count
			function updatePlayerCount() {
				var plural = "";
				if (remotePlayers.length > 0) {
					plural = "s";
				};
				playerCount.innerHTML = (remotePlayers.length+1)+" fighter"+plural+" online";
			};

			// Find player by ID
			function playerById(id) {
				for (var i = 0; i < remotePlayers.length; i++) {
					if (remotePlayers[i].id == id)
						return remotePlayers[i];
				};

				return false;
			};

			// Find player index by ID
			function indexOfByPlayerId(id) {
				for (var i = 0; i < remotePlayers.length; i++) {
					if (remotePlayers[i].id == id) {
						return i;
					};
				};

				return false;
			};

			// Find bullet by ID
			function bulletById(id) {
				for (var i = 0; i < bullets.length; i++) {
					if (bullets[i].id == id)
						return bullets[i];
				};

				return false;
			};

			// Find bullet index by ID
			function indexOfByBulletId(id) {
				for (var i = 0; i < bullets.length; i++) {
					if (bullets[i].id == id) {
						return i;
					};
				};

				return false;
			};

			// Find mine by ID
			function mineById(id) {
				for (var i = 0; i < mines.length; i++) {
					if (mines[i].id == id)
						return mines[i];
				};

				return false;
			};

			// Find mine index by ID
			function indexOfByMineId(id) {
				for (var i = 0; i < mines.length; i++) {
					if (mines[i].id == id) {
						return i;
					};
				};

				return false;
			};

			// Event listeners
			window.addEventListener("keydown", onKeydown, false);
			window.addEventListener("keyup", onKeyup, false);
			window.addEventListener("keypress", onKeypress, false);
			window.addEventListener("resize", resizeCanvas, false);

			function onKeydown(e) {
				var c = e.keyCode;

				if (localPlayer) {
					switch (c) {
						// Controls
						case 8: // Backspace
							if (chatMode) {
								e.preventDefault();
							};
							break;
						case 32: // Space
							if (chatMode) {
								return;
							};
							localPlayer.currentState.activeKeys.space = true;
							break;
						case 37: // Left
							localPlayer.currentState.activeKeys.left = true;
							break;
						case 38: // Up
							localPlayer.currentState.activeKeys.up = true;
							break;
						case 39: // Right
							localPlayer.currentState.activeKeys.right = true;
							break;
						case 40: // Down
							localPlayer.currentState.activeKeys.down = true;
							break;
						case 77: // M
							if (chatMode) {
								return;
							};
							localPlayer.currentState.activeKeys.mine = true;
							break;
						case 83: // S
							if (chatMode) {
								return;
							};
							if (sound.muted) {
								sound.unmute();
							} else {
								sound.mute();
							};
							break;
					};
				};

				//console.log("Key down [code: "+e.keyCode+"]");
			};

			function onKeyup(e) {
				var c = e.keyCode;

				if (localPlayer) {
					switch (c) {
						case 8: // Backspace
							if (chatMode) {
								e.preventDefault();
								chatMessage = chatMessage.slice(0, -1);
								$("#chatInput p").html(chatMessage);
								$("#chatLimit").html(60-chatMessage.length);
								return false;
							};
							break;
						case 13: // Enter
							if (chatMode) {
								if (chatMessage.length < 1) {
									return;
								};
								// Send message
								//console.log(chatMessage);
								var msg;
								if (chatMessage.length > 60) {
									msg = chatMessage.slice(0, 60);
									msg += "...";
								} else {
									msg = chatMessage;
								};
								socket.emit("message", formatMessage(MESSAGE_TYPE_CHAT, {m: msg}));
								chatMode = false;
								$("#chatInput").hide().find("p").html("");
							};
							break;
						case 27: // Escape
							if (chatMode) {
								chatMode = false;
								$("#chatInput").hide().find("p").html("");
							};
							break;
						case 32: // Space
							if (chatMode) {
								return;
							};
							localPlayer.currentState.activeKeys.space = false;
							break;
						case 37: // Left
							localPlayer.currentState.activeKeys.left = false;
							break;
						case 38: // Up
							localPlayer.currentState.activeKeys.up = false;
							break;
						case 39: // Right
							localPlayer.currentState.activeKeys.right = false;
							break;
						case 40: // Down
							localPlayer.currentState.activeKeys.down = false;
							break;
						case 77: // M
							if (chatMode) {
								return;
							};
							localPlayer.currentState.activeKeys.mine = false;
							break;
						case 84: // T
							if (chatMode) {
								return;
							};
							chatMessage = "";
							$("#chatLimit").html(60);
							$("#chatInput").show().find("p").html(chatMessage);
							chatMode = true;
							break;
					};
				};

				//console.log("Key down [code: "+e.keyCode+"]");
			};

			function onKeypress(e) {
				var c = e.keyCode || e.charCode;

				if (chatMode && c != 13 && c != 8) {
					chatMessage += (chatMessage.length < 60) ? String.fromCharCode(c) : "";
					$("#chatInput p").first().html(chatMessage);
					$("#chatLimit").html(60-chatMessage.length);
					return;
				};
			};

			function resizeCanvas(e) {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight-111; // Minus footer and header

				if (viewport != undefined) {
					viewport.dimensions.width = canvas.width;
					viewport.dimensions.height = canvas.height;
				};

				if (stars != undefined) {
					var xRatio = canvas.width/starsOriginalWidth;
					var yRatio = canvas.height/starsOriginalHeight;

					var starCount = stars.length,
						star,
						s;
					for (s = 0; s < starCount; s++) {
						star = stars[s];

						if (star == null) {
							continue;
						};

						star.pos.x *= xRatio;
						star.pos.y *= yRatio;
					};

					starsOriginalWidth = canvas.width;
					starsOriginalHeight = canvas.height;
				};

				var msg = formatMessage(MESSAGE_TYPE_UPDATE_PLAYER_SCREEN, {
					w: viewport.dimensions.width+50,
					h: viewport.dimensions.height+50
				});
				socket.emit("message", msg);
			};

			// Connect to game
			function connect() {
				// Connect to WebSocket server
				socket.connect();
			};

			// Check username on server
			function checkUsername(username) {
				if (socket) {
					if (username.match(/^[\d\w]*$/)) {
						if (username.length > 15) {
							return;
						}
						localPlayerUsername = username;

						var msg = formatMessage(MESSAGE_TYPE_CHECK_USERNAME, {u: localPlayerUsername});
						socket.emit('message', msg);
					};
				};
			};

			// Message types
			var MESSAGE_TYPE_UPDATE_REMOTE_PLAYER_STATE = 0,
				MESSAGE_TYPE_NEW_PLAYER = 1,
				MESSAGE_TYPE_REMOVE_PLAYER = 2,
				MESSAGE_TYPE_ENABLE_PLAYER_KEY = 3,
				MESSAGE_TYPE_DISABLE_PLAYER_KEY = 4,
				MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_POSITION = 5,
				MESSAGE_TYPE_PING = 6,
				MESSAGE_TYPE_NEW_BULLET = 7,
				MESSAGE_TYPE_UPDATE_BULLET_STATE = 8,
				MESSAGE_TYPE_REMOVE_BULLET = 9,
				MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_COLOUR = 10,
				MESSAGE_TYPE_UPDATE_PLAYER_SCREEN = 11,
				MESSAGE_TYPE_KILLED_BY = 12,
				MESSAGE_TYPE_UPDATE_SCORE = 13,
				MESSAGE_TYPE_CHECK_USERNAME = 14,
				MESSAGE_TYPE_CHAT = 15,
				MESSAGE_TYPE_NEW_MINE = 16,
				MESSAGE_TYPE_REMOVE_MINE = 17,
				//MESSAGE_TYPE_CHECK_IN = 16,

			// Run game
				runUpdate = true,

			// Fixed physics update
				t = 0,
				dt = 1/30,
				dtdt = dt*dt,

			// Socket settings
				socketHost = window.location.hostname + ":8000",
				// socketHost = "localhost:8000",
				// socket = new io.Socket(socketHost, {port: 8000, transports: ["websocket"]}),
				// socket = io.connect(socketHost, {port: 8000, transports: ["websocket"]}),
				socket = io(socketHost, {transports: ['websocket']}),

			// Netgraph
				net = new NetGraph(),

			// Game world
				viewport = new Viewport(canvas.width, canvas.height),
				stars = [],
				starsOriginalWidth = canvas.width,
				starsOriginalHeight = canvas.height,

			// Players
				localPlayer,
				localPlayerUsername,
				remotePlayers = [],

			// Weapons
				bullets = [],
				mines = [],

			// Chat
				chatMode = false,
				chatMessage,
				chatMessages = [],

			// Sound setup
				sound,
				flashvars = {},
				params = {allowscriptaccess: "always"};

			swfobject.embedSWF("lib/Sounds.swf", "soundContainer", "0", "0", "9.0.0", "", flashvars, params, "", function(err) {
				sound = new Sound();
			});

			// Set up stars
			createStars();

			// EVENTS
			// connect, connecting, connect_failed, message, close,
			// disconnect, reconnect, reconnecting, reconnect_failed

			// WebSocket connection successful
			socket.on("connect", function(){
				console.log("Connected");
			});

			// WebSocket connection failed
			socket.on("connect_failed", function() {
				console.log("Connect failed");
			});

			// WebSocket disconnection
			socket.on("disconnect", function() {
				console.log("Disconnected");
			});

			// WebSocket message received
			socket.on("message", function(data){
				var msg = BISON.decode(data);
				// console.log("Message received: ", msg);

				net.addTmpData(data.length);

				// Move this to a dedicate message queuing system
				if (msg.z !== undefined) {
					switch (msg.z) {
						case MESSAGE_TYPE_PING:
							if (msg.t) {
								socket.emit("message", formatMessage(MESSAGE_TYPE_PING, {t: msg.t}));
							};

							if (msg.p) {
								net.addPing(msg.p);
								net.addData();
							};
							break;
						case MESSAGE_TYPE_CHECK_USERNAME:
							if (msg.c != 1) {
								switch (msg.r) {
									case 1:
										$("#usernameError").html("This username is in use, please choose another");
										break;
									case 2:
										$("#usernameError").html("Please only use letters and numbers in your username");
										break;
									case 3:
										$("#usernameError").html("Please keep your username 15 characters or less");
										break;
								};
								return;
							};

							sound.play("background");

							// Is it a good idea to intermingle jQuery with the raw game JavaScript? It sure beats creating my own animation tools
							$("#overlay").stop().animate({backgroundColor: "rgba(0, 0, 0, 0)"});
							$("#intro").stop().fadeOut();

							localPlayer = new Player({id: msg.id, local: true, x: 1000, y: 1000, angle: 0, colour: false, username: localPlayerUsername});
							// Move to message queuing system
							var msg = formatMessage(MESSAGE_TYPE_NEW_PLAYER, {u: localPlayerUsername, w: viewport.dimensions.width+50, h: viewport.dimensions.height+50, s: localPlayer.currentState});
							socket.emit("message", msg);

							updatePlayerCount();
							break;
					};
				};

				if (msg.z !== undefined && localPlayer != undefined) {
					switch (msg.z) {
						case MESSAGE_TYPE_NEW_PLAYER:
							var colour = (msg.c) ? msg.c : false;
							addRemotePlayer({id: msg.id, state: msg.s, colour: colour, username: msg.u});
							updatePlayerCount();
							break;
						case MESSAGE_TYPE_REMOVE_PLAYER:
							var player = playerById(msg.id);
							if (player) {
								console.log("Remove player: ", msg.id);
								remotePlayers.splice(indexOfByPlayerId(msg.id), 1);
							};
							updatePlayerCount();
							break;
						case MESSAGE_TYPE_UPDATE_REMOTE_PLAYER_STATE:
							//console.log(msg);
							var player = playerById(msg.id);
							if (player) {
								// Only update position (must be off screen)
								if (msg.a == undefined) {
									if (msg.p != undefined) {
										player.previousState.pos = player.currentState.pos;
										player.currentState.pos = msg.p;
									};
									if (msg.h != undefined) {
										player.previousState.health = player.currentState.health;
										player.currentState.health = msg.h;
									};
									break;
								};

								player.previousState.pos = player.currentState.pos;
								player.previousState.angle = player.currentState.angle;
								player.previousState.moving = player.currentState.moving;
								player.previousState.health = player.currentState.health;

								if (msg.p != undefined) {
									player.currentState.pos = msg.p;
								};
								if (msg.a != undefined) {
									player.currentState.angle = msg.a;
								};
								if (msg.m != undefined) {
									player.currentState.moving = msg.m;
								};
								if (msg.h != undefined) {
									player.currentState.health = msg.h;
								};

								if (player.previousState.health - player.currentState.health > 30 || player.currentState.health <= 0) {
									sound.play("die");
								};

								if (msg.a != undefined && player.previousState.health <= 0 && player.currentState.health >= 90) {
									sound.play("respawn");
								};
							};
							break;
						case MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_POSITION:
							if (localPlayer) {
								localPlayer.previousState.angle = localPlayer.currentState.angle;
								localPlayer.previousState.moving = localPlayer.currentState.moving;
								localPlayer.previousState.health = localPlayer.currentState.health;

								if (msg.a != undefined) {
									localPlayer.currentState.angle = msg.a;
								};
								if (msg.m != undefined) {
									localPlayer.currentState.moving = msg.m;
								};
								if (msg.h != undefined) {
									localPlayer.currentState.health = msg.h;
								};

								viewport.previousPos.x = viewport.pos.x;
								viewport.previousPos.y = viewport.pos.y;
								if (msg.p != undefined) {
									viewport.pos.x = msg.p.x;
									viewport.pos.y = msg.p.y;
								};

								if (localPlayer.previousState.health - localPlayer.currentState.health > 30 || localPlayer.currentState.health <= 0) {
									sound.play("die");
								};

								if (localPlayer.previousState.health <= 0 && localPlayer.currentState.health >= 90) {
									viewport.previousPos.x = viewport.pos.x;
									viewport.previousPos.y = viewport.pos.y;

									// Set up stars
									createStars();

									sound.play("respawn");
								};
							};
							break;
						case MESSAGE_TYPE_UPDATE_LOCAL_PLAYER_COLOUR:
							if (localPlayer) {
								localPlayer.colour.c = msg.c;
							};
							break;
						case MESSAGE_TYPE_NEW_BULLET:
							var bullet;
							//localPos = viewport.worldToScreen(msg.x, msg.y);
							bullet = new Bullet({id: msg.id, x: msg.x, y: msg.y, angle: msg.a});
							bullets.push(bullet);
							sound.play("laser");
							break;
						/*case MESSAGE_TYPE_UPDATE_BULLET_STATE: // Depricated
							var incBullets = msg.b, bullet, localPos, b, bulletCount = bullets.length;

							for (b = 0; b < bulletCount; b++) {
								if (incBullets[b] == undefined) {
									continue;
								};

								bullet = bulletById(incBullets[b].id);
								if (bullet) {
									localPos = viewport.worldToScreen(incBullets[b].x, incBullets[b].y);
									bullet.currentState.pos.x = localPos.x;
									bullet.currentState.pos.y = localPos.y;
								};
							};
							break;*/
						case MESSAGE_TYPE_REMOVE_BULLET:
							//console.log("Remove bullet", msg.id);
							var bullet = bulletById(msg.id);
							if (bullet) {
								bullets.splice(indexOfByBulletId(msg.id), 1);
							};
							break;
						case MESSAGE_TYPE_NEW_MINE:
							var mine;
							//localPos = viewport.worldToScreen(msg.x, msg.y);
							mine = new Mine({id: msg.id, playerId: msg.pid, x: msg.x, y: msg.y});
							mines.push(mine);
							//sound.play("mine");
							break;
						case MESSAGE_TYPE_REMOVE_MINE:
							//console.log("Remove bullet", msg.id);
							var mine = mineById(msg.id);
							if (mine) {
								mines.splice(indexOfByMineId(msg.id), 1);
							};
							break;
						case MESSAGE_TYPE_KILLED_BY:
							var player = playerById(msg.id);
							if (player) {
								killedBy.innerHTML = player.username+" just killed you";
								setTimeout(function() {
									killedBy.innerHTML = "";
								}, 5000);
							};
							break;
						case MESSAGE_TYPE_UPDATE_SCORE:
							score.innerHTML = msg.s;
							break;
						case MESSAGE_TYPE_CHAT:
							if (msg.m) {
								var player, chat = $("#chatDisplay");
								player = playerById(msg.id);

								if (!player) {
									player = (msg.id == socket.id) ? localPlayer : false;
								};

								if (player) {
									if (chatMessages.length > 9) {
										chatMessages.shift();
									};

									if (chat.find("li").size() > 9) {
										chat.find("li").first().fadeOut(500, function() {
											$(this).remove();
										});
									};

									chatMessages.push(msg.m);
									var chatHTML = $("<li><span>"+player.username+":</span> "+msg.m+"</li>\n").hide();
									chatHTML.appendTo(chat).fadeIn();
								};
							};
							break;
					};
				};
			});

			// Main update loop
			function update() {
				// Update local input
				if (localPlayer != null) {
					localPlayer.currentState.updateKeys();
				};

				ctx.clearRect(0, 0, canvas.width, canvas.height);

				viewport.draw(ctx);

				var playerMoveDelta = new Vector({x: viewport.pos.x-viewport.previousPos.x, y: viewport.pos.y-viewport.previousPos.y}),
					starCount = stars.length,
					star,
					s;

				for (s = 0; s < starCount; s++) {
					star = stars[s];

					if (!star || star == null) {
						continue;
					};

					if (Math.abs(playerMoveDelta.x) > 0.5 || Math.abs(playerMoveDelta.y) > 0.5) {
						star.update(playerMoveDelta);

						// Wrap stars around screen
						star.pos.x = (star.pos.x < 0) ? canvas.width : star.pos.x;
						star.pos.x = (star.pos.x > canvas.width) ? 0 : star.pos.x;
						star.pos.y = (star.pos.y < 0) ? canvas.height : star.pos.y;
						star.pos.y = (star.pos.y > canvas.height) ? 0 : star.pos.y;
					};

					star.draw(ctx);
				};

				var b, bullet, deadBullets = [], bulletCount = bullets.length;
				if (bulletCount > 0) {
					for (b = 0; b < bulletCount; b++) {
						bullet = bullets[b];
						if (bullet) {
							// Local physics update (non-authoritative)
							bullet.update();

							if (bullet.currentState.age < 75) {
								bullet.draw(ctx);
							} else {
								deadBullets.push(bullet);
							};
						};
					};
				};

				// Remove dead bullets
				var db, bulletIndex, deadBulletCount = deadBullets.length;
				for (db = 0; db < deadBulletCount; db++) {
					bullet = deadBullets[db];
					bulletIndex = indexOfByBulletId(deadBullets[db].id);

					if (bullet) {
						bullets.splice(bulletIndex, 1);
					};
				};

				var m, mine, deadMines = [], mineCount = mines.length;
				if (mineCount > 0) {
					for (m = 0; m < mineCount; m++) {
						mine = mines[m];
						if (mine) {
							mine.update();

							if (mine.currentState.age < 1500) {
								mine.draw(ctx);
							} else {
								deadMines.push(mine);
							};
						};
					};
				};

				// Remove dead mines
				var dm, mineIndex, deadMineCount = deadMines.length;
				for (dm = 0; dm < deadMineCount; dm++) {
					mine = deadMines[dm];
					mineIndex = indexOfByMineId(deadMines[dm].id);

					if (mine) {
						mines.splice(mineIndex, 1);
					};
				};

				var i, player, removedPlayers = [], playerCount = remotePlayers.length;
				if (playerCount > 0) {
					for (i = 0; i < playerCount; i++) {
						player = remotePlayers[i];
						if (player) {
							if (viewport.withinBounds(player.currentState.pos.x, player.currentState.pos.y)) {
								player.draw(ctx);
							// Player is outside of the viewport
							} else {
								// Draw an arrow at the edge of the viewport indicating where the player is
								var localScreenPos = viewport.worldToScreen(viewport.pos.x, viewport.pos.y);
								var screenPos = viewport.worldToScreen(player.currentState.pos.x, player.currentState.pos.y);

								var x1 = localScreenPos.x;
								var y1 = localScreenPos.y;
								var x2 = screenPos.x;
								var y2 = screenPos.y;

								var angle = Math.atan2(y1-y2, x1-x2);

								var x3;
								var y3;
								var x4;
								var y4;

								var px;
								var py;

								// Check bottom edge
								if (screenPos.y > canvas.height) {
									x3 = 0;
									y3 = canvas.height;
									x4 = canvas.width;
									y4 = canvas.height;

									// Can this formula be simplified?
									px = ((((x1*y2)-(y1*x2))*(x3-x4))-((x1-x2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									py = ((((x1*y2)-(y1*x2))*(y3-y4))-((y1-y2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));

									px = px;
									py -= 10;
								};

								// Check top edge
								if (screenPos.y < 0) {
									x3 = 0;
									y3 = 0;
									x4 = canvas.width;
									y4 = 0;

									px = ((((x1*y2)-(y1*x2))*(x3-x4))-((x1-x2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									py = ((((x1*y2)-(y1*x2))*(y3-y4))-((y1-y2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));

									px = px;
									py += 10;
								};

								// Check left edge
								if (screenPos.x < 0) {
									x3 = 0;
									y3 = 0;
									x4 = 0;
									y4 = canvas.height;

									px = ((((x1*y2)-(y1*x2))*(x3-x4))-((x1-x2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									py = ((((x1*y2)-(y1*x2))*(y3-y4))-((y1-y2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));

									px += 10;
									py = py;
								};

								// Check right edge
								if (screenPos.x > canvas.width) {
									x3 = canvas.width;
									y3 = 0;
									x4 = canvas.width;
									y4 = canvas.height;

									px = ((((x1*y2)-(y1*x2))*(x3-x4))-((x1-x2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));
									py = ((((x1*y2)-(y1*x2))*(y3-y4))-((y1-y2)*((x3*y4)-(y3*x4)))) / (((x1-x2)*(y3-y4))-((y1-y2)*(x3-x4)));

									px -= 10;
									py = py;
								};

								ctx.save();
								ctx.translate(px, py);
								ctx.rotate(angle);
								ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
								ctx.beginPath();
								ctx.moveTo(-5, 0);
								ctx.lineTo(5, 5);
								ctx.lineTo(5, -5);
								ctx.closePath();
								ctx.fill();
								ctx.restore();
							};
						};
					};
				};

				// Move draw functionality to another method?
				if (localPlayer != null) {
					localPlayer.draw(ctx);
				};

				// Move to message queuing system
				if (localPlayer != null && localPlayer.currentState.currentKeys.left && localPlayer.currentState.currentKeys.left != localPlayer.currentState.previousKeys.left) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 37});
					socket.emit("message", msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.left && localPlayer.currentState.currentKeys.left != localPlayer.currentState.previousKeys.left) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 37});
					socket.emit("message", msg);
				};

				if (localPlayer != null && localPlayer.currentState.currentKeys.up && localPlayer.currentState.currentKeys.up != localPlayer.currentState.previousKeys.up) {
					sound.play("thrust");
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 38});
					socket.emit("message", msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.up && localPlayer.currentState.currentKeys.up != localPlayer.currentState.previousKeys.up) {
					sound.stop("thrust");
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 38});
					socket.emit("message", msg);
				};

				if (localPlayer != null && localPlayer.currentState.currentKeys.right && localPlayer.currentState.currentKeys.right != localPlayer.currentState.previousKeys.right) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 39});
					socket.emit("message", msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.right && localPlayer.currentState.currentKeys.right != localPlayer.currentState.previousKeys.right) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 39});
					socket.emit("message", msg);
				};

				if (localPlayer != null && localPlayer.currentState.currentKeys.down && localPlayer.currentState.currentKeys.down != localPlayer.currentState.previousKeys.down) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 40});
					socket.emit("message", msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.down && localPlayer.currentState.currentKeys.down != localPlayer.currentState.previousKeys.down) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 40});
					socket.emit("message", msg);
				};

				// Fire weapon
				if (localPlayer != null && localPlayer.currentState.currentKeys.space && localPlayer.currentState.currentKeys.space != localPlayer.currentState.previousKeys.space) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 32});
					socket.emit("message", msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.space && localPlayer.currentState.currentKeys.space != localPlayer.currentState.previousKeys.space) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 32});
					socket.emit("message", msg);
				};

				// Fire mine
				if (localPlayer != null && localPlayer.currentState.currentKeys.mine && localPlayer.currentState.currentKeys.mine != localPlayer.currentState.previousKeys.mine) {
					var msg = formatMessage(MESSAGE_TYPE_ENABLE_PLAYER_KEY, {k: 77});
					socket.emit("message", msg);
				} else if (localPlayer != null && !localPlayer.currentState.currentKeys.mine && localPlayer.currentState.currentKeys.mine != localPlayer.currentState.previousKeys.mine) {
					var msg = formatMessage(MESSAGE_TYPE_DISABLE_PLAYER_KEY, {k: 77});
					socket.emit("message", msg);
				};

				// Draw netgraph
				net.draw(ctx);

				// Schedule next game update
				// Move to requestAnimationFrame to better handle differing hardware
				if (runUpdate) {
					setTimeout(update, 1000/60); // Remember, this is however long it take to update PLUS 60ms
				};
			};

			// Move game time forward
			t += dt;

			// Connect to server
			// connect();

			// Start main update loop
			update();
		</script>

		<!-- Google Analytics -->
		<!-- <script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-19570160-1']);
		_gaq.push(['_trackPageview']);

		(function() {
		var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
		</script> -->
	</body>
</html>
